diff --git a/TRADEOFFS.md b/TRADEOFFS.md
new file mode 100644
index 0000000..b2b7dd9
--- /dev/null
+++ b/TRADEOFFS.md
@@ -0,0 +1,82 @@
+# TRADEOFFS
+
+## Language Choice
+
+I picked Java based on a mix of safety and ecosystem support.
+
+Parsing Twitter’s archive involves nested JSON. Java’s static typing
+caught mismatches at compile time, so I didn’t have to wait until
+runtime to discover that a field name or structure didn’t line
+up.
+
+Ecosystem: Libraries like Gson, OpenCSV, and Google’s GenAI SDK all have
+mature Java support. That meant fewer surprises and reliable documentation.
+
+Error handling: Checked exceptions forced me to be explicit about I/O and
+API failures. This made retry logic, file recovery, and fallback behavior
+more predictable.
+
+Python would have been faster to write, but Java’s type system prevented
+subtle bugs and made the whole pipeline feel sturdier. With newer features
+like records and text blocks, verbosity wasn’t much of a problem.
+
+## Architecture
+
+I used a small component-based design so each responsibility stayed
+isolated:
+
+- csv package: writes deletion results and maintains a checkpoint file
+- AI_Client package: handles GenAI calls, rate limits, and retries
+- parser package: unwraps Twitter’s JS-style JSON and maps it into Java
+  records
+- orchestrator package: coordinates workflow - load state, parse tweets,
+  evaluate, save results
+- Interface-based: Orchestrator depends on `TweetEvaluator` interface,
+  not a concrete AI client, so, swapping providers only requires one new
+  implementation.
+
+This setup keeps the code approachable, easy to test, and simple to adjust
+in the future
+
+## Error Handling
+
+The app is built to keep moving even when things fail.
+Retry logic: exponential backoff (1s, 2s, 4s delays)
+handles transient failures like network or api issues.
+
+Checkpoint recovery: after each tweet is evaluated, its ID is immediately
+persisted so the program never reprocesses old work.
+
+Graceful fallback: tweets that still fail after all retries get tagged as
+`API_ERROR` and the system continues with the next one.
+
+The idea is to avoid stopping the whole job because of a single problematic
+tweet.
+
+## Concurrency Strategy
+
+I processed tweets one at a time, intentionally.
+Why sequential?
+
+- It keeps the logic simple
+- The 4-second gaps naturally stay under Gemini’s rate limits
+- Retries are isolated and predictable
+- Checkpointing is straightforward - check point after each tweet, write 
+  and move on
+
+Batching 10–15 tweets concurrently would reduce total runtime, but it would
+also introduce thread coordination, synchronized I/O, and more complicated
+error handling. For a one-off data-cleaning task, that extra complexity
+didn’t feel worth it
+
+## Performance vs Safety
+
+- Sequential processing is slower but safer
+- Per-tweet checkpoints reduce the risk of losing progress
+- Retry attempts add a few extra seconds but prevent transient failures
+  from breaking the pipeline
+- Conservative rate limiting avoids hitting API blocks
+
+Design principle: this application favours reliability over speed. When a
+process runs for hours unattended, preventing crashes and data loss
+matters more than shaving 30 minutes off runtime.
\ No newline at end of file
diff --git a/criteria.json b/criteria.json
new file mode 100644
index 0000000..339f641
--- /dev/null
+++ b/criteria.json
@@ -0,0 +1,9 @@
+{
+  "forbiddenWords": [
+    "crypto",
+    "NFT"
+  ],
+  "professionalCheck": true,
+  "tone": "respectful and thoughtful",
+  "excludePolitics": false
+}
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000..4b5e78f
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.tweetaudit</groupId>
+    <artifactId>tweet-audit</artifactId>
+    <version>1.0-SNAPSHOT</version>
+
+    <properties>
+        <maven.compiler.source>21</maven.compiler.source>
+        <maven.compiler.target>21</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.projectlombok</groupId>
+            <artifactId>lombok</artifactId>
+            <version>1.18.40</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.genai</groupId>
+            <artifactId>google-genai</artifactId>
+            <version>1.27.0</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+            <version>2.11.0</version>
+        </dependency>
+        <dependency>
+            <groupId>com.opencsv</groupId>
+            <artifactId>opencsv</artifactId>
+            <version>5.12.0</version>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <version>5.12.2</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-shade-plugin</artifactId>
+                <version>3.5.1</version>
+                <executions>
+                    <execution>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>shade</goal>
+                        </goals>
+                        <configuration>
+                            <transformers>
+                                <transformer
+                                        implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
+                                    <mainClass>Main</mainClass>
+                                </transformer>
+                            </transformers>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
\ No newline at end of file
diff --git a/src/main/java/AI_Client/EvaluationCriteria.java b/src/main/java/AI_Client/EvaluationCriteria.java
new file mode 100644
index 0000000..e5ea14c
--- /dev/null
+++ b/src/main/java/AI_Client/EvaluationCriteria.java
@@ -0,0 +1,46 @@
+package AI_Client;
+
+import java.util.List;
+
+public record EvaluationCriteria(
+        List<String> forbiddenWords,
+        boolean professionalCheck,
+        String tone,
+        boolean excludePolitics
+) {
+    public static EvaluationCriteria defaults() {
+        return new EvaluationCriteria(
+                List.of(),
+                true,
+                "respectful and thoughtful",
+                false
+        );
+    }
+
+    public String toPromptText() {
+        StringBuilder criteria = new StringBuilder();
+
+        criteria.append("Evaluate with a ").append(tone).append(" tone.\n\n");
+
+        criteria.append("Flag tweets that:\n");
+        criteria.append("- Contains offensive language\n");
+        criteria.append("- Reflects opinions I might regret publicly " +
+                "expressing\n");
+
+        if (professionalCheck) {
+            criteria.append("- Could be misunderstood out of context\n");
+            criteria.append("- Fail professional standards\n");
+        }
+
+        if (!forbiddenWords.isEmpty()) {
+            criteria.append("- Contain these words\n")
+                    .append(String.join(", ", forbiddenWords))
+                    .append("\n");
+        }
+
+        if (excludePolitics) {
+            criteria.append("- Contains political content\n");
+        }
+        return criteria.toString();
+    }
+}
diff --git a/src/main/java/AI_Client/GeminiClient.java b/src/main/java/AI_Client/GeminiClient.java
new file mode 100644
index 0000000..1dc984d
--- /dev/null
+++ b/src/main/java/AI_Client/GeminiClient.java
@@ -0,0 +1,89 @@
+package AI_Client;
+
+import com.google.genai.Client;
+import com.google.genai.types.*;
+import AI_Client.retry.RateLimiter;
+import AI_Client.retry.RetryHandler;
+import model.EvaluationResult;
+import model.enums.ProcessingStatus;
+
+import java.util.Objects;
+
+public class GeminiClient implements TweetEvaluator {
+    private final EvaluationCriteria criteria;
+    private final RateLimiter rateLimiter = new RateLimiter();
+    private final RetryHandler retryHandler = new RetryHandler();
+
+    public GeminiClient(EvaluationCriteria criteria) {
+        this.criteria = criteria;
+    }
+
+    public EvaluationResult evaluateTweet(String tweetText) {
+        rateLimiter.waitIfNeeded();
+
+        return retryHandler.execute(
+                () -> makeApiCall(tweetText),
+                new EvaluationResult(ProcessingStatus.API_ERROR,
+                        "Failed after retries")
+        );
+
+    }
+
+    private EvaluationResult makeApiCall(String tweetText) {
+        try (Client client = new Client()) {
+            String prompt = buildPrompt(tweetText);
+            GenerateContentConfig config =
+                    GenerateContentConfig.builder()
+                            .thinkingConfig(ThinkingConfig.builder()
+                                    .thinkingBudget(0))
+                            .systemInstruction(
+                                    Content.fromParts(Part.fromText("You" +
+                                            " are evaluating tweets for " +
+                                            "deletion. Be concise. " +
+                                            "Always start responses with" +
+                                            " DELETE or KEEP. Followed " +
+                                            "by a brief reason not more " +
+                                            "than 10/15 words."))
+                            )
+                            .build();
+
+            GenerateContentResponse response = client
+                    .models.generateContent(
+                            "gemini-2.5-flash",
+                            prompt,
+                            config
+                    );
+            String responseText = response.text();
+
+            return parseResponse(responseText);
+        }
+    }
+
+    private String buildPrompt(String tweetText) {
+        return """
+                Evaluate the following tweet based on these criteria:
+                %s
+                Tweet: "%s"
+                """.formatted(criteria.toPromptText(), tweetText);
+
+    }
+
+    private EvaluationResult parseResponse(String responseText) {
+
+        ProcessingStatus status;
+        if (Objects.requireNonNull(responseText)
+                .startsWith("DELETE")) {
+            status = ProcessingStatus.DELETE;
+        } else if (responseText.startsWith("KEEP")) {
+            status = ProcessingStatus.KEEP;
+        } else {
+            status = ProcessingStatus.NEEDS_MANUAL_REVIEW;
+        }
+
+        String reason =
+                responseText.substring(responseText.indexOf('.') + 1)
+                        .trim();
+
+        return new EvaluationResult(status, reason);
+    }
+}
diff --git a/src/main/java/AI_Client/TweetEvaluator.java b/src/main/java/AI_Client/TweetEvaluator.java
new file mode 100644
index 0000000..18ec4b1
--- /dev/null
+++ b/src/main/java/AI_Client/TweetEvaluator.java
@@ -0,0 +1,7 @@
+package AI_Client;
+
+import model.EvaluationResult;
+
+public interface TweetEvaluator {
+    EvaluationResult evaluateTweet(String tweetText);
+}
diff --git a/src/main/java/AI_Client/retry/RateLimiter.java b/src/main/java/AI_Client/retry/RateLimiter.java
new file mode 100644
index 0000000..a26c080
--- /dev/null
+++ b/src/main/java/AI_Client/retry/RateLimiter.java
@@ -0,0 +1,24 @@
+package AI_Client.retry;
+
+public class RateLimiter {
+    private static final long MIN_INTERVAL_MS = 4000;
+    private long lastRequestTime = 0;
+
+    public void waitIfNeeded() {
+        long now = System.currentTimeMillis();
+        long elapsedTime = now - lastRequestTime;
+        if (elapsedTime < MIN_INTERVAL_MS) {
+            sleep(MIN_INTERVAL_MS - elapsedTime);
+        }
+        lastRequestTime = System.currentTimeMillis();
+    }
+
+    public void sleep(long millis) {
+        try {
+            Thread.sleep(millis);
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new RuntimeException("Interrupted", e);
+        }
+    }
+}
diff --git a/src/main/java/AI_Client/retry/RetryHandler.java b/src/main/java/AI_Client/retry/RetryHandler.java
new file mode 100644
index 0000000..7853e80
--- /dev/null
+++ b/src/main/java/AI_Client/retry/RetryHandler.java
@@ -0,0 +1,35 @@
+package AI_Client.retry;
+
+import java.util.function.Supplier;
+
+public class RetryHandler {
+    private static final int MAX_RETRIES = 3;
+
+    public <T> T execute(Supplier<T> action, T fallbackValue) {
+        int attempts = 0;
+        long delay = 1000;
+
+        while (attempts < MAX_RETRIES) {
+            try {
+                return action.get();
+            } catch (Exception e) {
+                attempts++;
+                if (attempts >= MAX_RETRIES) {
+                    return fallbackValue;
+                }
+                sleep(delay);
+                delay *= 2;
+            }
+        }
+        return fallbackValue;
+    }
+
+    private void sleep(long ms) {
+        try {
+            Thread.sleep(ms);
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new RuntimeException("Interrupted", e);
+        }
+    }
+}
diff --git a/src/main/java/Main.java b/src/main/java/Main.java
new file mode 100644
index 0000000..8143840
--- /dev/null
+++ b/src/main/java/Main.java
@@ -0,0 +1,54 @@
+import AI_Client.EvaluationCriteria;
+import config.ConfigLoader;
+import orchestrator.TweetAuditOrchestrator;
+
+import java.io.IOException;
+
+public class Main {
+    public static void main(String[] args) {
+
+        if (args.length < 2) {
+            System.err.println(
+                    "Usage: tweet-audit <archivePath> <outputPath> " +
+                            "<configPath>");
+            System.exit(1);
+        }
+
+        if (args.length < 3) {
+            System.err.println(
+                    "Usage: tweet-audit <archivePath> <outputPath> <configPath>");
+            System.exit(1);
+        }
+
+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
+            System.out.println("\nShutting down...");
+            System.out.println("Progress saved. you can resume later.");
+        }));
+
+        System.out.println("""
+                ================================
+                        TWEET AUDIT TOOL
+                ================================
+                """);
+
+        String inputFilePath = args[0];
+        String outputFilePath = args[1];
+        String configPath = args[2];
+
+        try {
+            String apiKey = System.getenv("GEMINI_API_KEY");
+            if (apiKey == null || apiKey.isEmpty()) {
+                System.err.println(
+                        "GEMINI_API_KEY environment variable not set");
+                System.exit(1);
+            }
+
+            EvaluationCriteria criteria = ConfigLoader.load(configPath);
+            new TweetAuditOrchestrator().run(inputFilePath,
+                    outputFilePath, criteria);
+        } catch (IOException e) {
+            System.err.println("Error: " + e.getMessage());
+            System.exit(1);
+        }
+    }
+}
diff --git a/src/main/java/config/ConfigLoader.java b/src/main/java/config/ConfigLoader.java
new file mode 100644
index 0000000..3af9da8
--- /dev/null
+++ b/src/main/java/config/ConfigLoader.java
@@ -0,0 +1,30 @@
+package config;
+
+import AI_Client.EvaluationCriteria;
+import com.google.gson.Gson;
+
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.List;
+
+public class ConfigLoader {
+    public static EvaluationCriteria load(String path) throws IOException {
+        Gson gson = new Gson();
+        CriteriaConfig config = gson.fromJson(new FileReader(path),
+                CriteriaConfig.class);
+
+        return new EvaluationCriteria(
+                config.forbiddenWords,
+                config.professionalCheck,
+                config.tone,
+                config.excludePolitics
+        );
+    }
+
+    private static class CriteriaConfig {
+        List<String> forbiddenWords;
+        boolean professionalCheck;
+        String tone;
+        boolean excludePolitics;
+    }
+}
diff --git a/src/main/java/csv/CsvHandler.java b/src/main/java/csv/CsvHandler.java
new file mode 100644
index 0000000..5639aca
--- /dev/null
+++ b/src/main/java/csv/CsvHandler.java
@@ -0,0 +1,72 @@
+package csv;
+
+import com.opencsv.CSVWriter;
+import lombok.extern.slf4j.Slf4j;
+import model.enums.ProcessingStatus;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.util.HashSet;
+
+import java.util.Set;
+
+
+@Slf4j
+public class CsvHandler {
+
+    private static final String[] CSV_HEADERS =
+            {"id", "text", "status", "reason"};
+    private final File file;
+    private final File checkpointFile;
+
+    public CsvHandler(String fileName) {
+        this.file = new File(fileName);
+        this.checkpointFile = new File(fileName.replace(".csv",
+                "_checkpoint.txt"));
+    }
+
+    public Set<String> getProcessedTweetIds() {
+
+        if (!checkpointFile.exists()) {
+            return new HashSet<>();
+        }
+
+        try {
+            return new HashSet<>(
+                    Files.readAllLines(checkpointFile.toPath()));
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void writeResult(String tweetId, String tweetText,
+                            ProcessingStatus status, String reason) {
+        appendToCheckpoint(tweetId);
+        if (status == ProcessingStatus.DELETE) {
+            writeToResultCsv(tweetId, tweetText, reason);
+        }
+    }
+
+    private void appendToCheckpoint(String tweetId) {
+        try (FileWriter fw = new FileWriter(checkpointFile, true)) {
+            fw.write(tweetId + "\n");
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void writeToResultCsv(String tweetId, String tweetText,
+                                  String reason) {
+        boolean fileExists = file.exists();
+        try (CSVWriter writer = new CSVWriter(
+                new FileWriter(file, true))) {
+
+            if (!fileExists) {
+                writer.writeNext(new String[]{"id", "text", "reason"});
+            }
+            writer.writeNext(new String[]{tweetId, tweetText, reason});
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/main/java/model/EvaluationResult.java b/src/main/java/model/EvaluationResult.java
new file mode 100644
index 0000000..0072d7c
--- /dev/null
+++ b/src/main/java/model/EvaluationResult.java
@@ -0,0 +1,9 @@
+package model;
+
+import model.enums.ProcessingStatus;
+
+public record EvaluationResult(
+        ProcessingStatus status,
+        String reason
+) {
+}
diff --git a/src/main/java/model/Tweet.java b/src/main/java/model/Tweet.java
new file mode 100644
index 0000000..6dce03f
--- /dev/null
+++ b/src/main/java/model/Tweet.java
@@ -0,0 +1,8 @@
+package model;
+
+public record Tweet(
+        String id,
+        String text,
+        String status,
+        String reason) {
+}
diff --git a/src/main/java/model/enums/ProcessingStatus.java b/src/main/java/model/enums/ProcessingStatus.java
new file mode 100644
index 0000000..4aef2ce
--- /dev/null
+++ b/src/main/java/model/enums/ProcessingStatus.java
@@ -0,0 +1,8 @@
+package model.enums;
+
+public enum ProcessingStatus {
+    DELETE,
+    KEEP,
+    NEEDS_MANUAL_REVIEW,
+    API_ERROR
+}
diff --git a/src/main/java/orchestrator/TweetAuditOrchestrator.java b/src/main/java/orchestrator/TweetAuditOrchestrator.java
new file mode 100644
index 0000000..aba6110
--- /dev/null
+++ b/src/main/java/orchestrator/TweetAuditOrchestrator.java
@@ -0,0 +1,92 @@
+package orchestrator;
+
+import csv.CsvHandler;
+import AI_Client.EvaluationCriteria;
+import AI_Client.GeminiClient;
+import AI_Client.TweetEvaluator;
+import model.EvaluationResult;
+import model.Tweet;
+import parser.TwitterArchiveParser;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+import java.util.Scanner;
+import java.util.Set;
+
+public class TweetAuditOrchestrator {
+
+    public void run(String archivePath, String outputCsvPath,
+                    EvaluationCriteria criteria)
+            throws IOException {
+        validateFile(archivePath);
+
+        TweetEvaluator evaluator = new GeminiClient(criteria);
+        CsvHandler csvHandler = new CsvHandler(outputCsvPath);
+        TwitterArchiveParser parser = new TwitterArchiveParser();
+
+        Set<String> processedIds = csvHandler.getProcessedTweetIds();
+        List<Tweet> allTweets = parser.parseTweets(archivePath);
+
+        int totalTweets = allTweets.size();
+        int alreadyProcessed = processedIds.size();
+        int remainingTweets = totalTweets - alreadyProcessed;
+
+        System.out.println("Total Tweets: " + totalTweets);
+        System.out.println("Processed Tweets: " + alreadyProcessed);
+        System.out.println("Remaining Tweets: " + remainingTweets);
+
+        if (remainingTweets == 0) {
+            System.out.println("No tweets left in archive");
+            return;
+        }
+
+        System.out.print("Continue? (y/n): ");
+        Scanner scanner = new Scanner(System.in);
+        String answer = scanner.nextLine().trim().toLowerCase();
+
+        if (!answer.equals("y")) {
+            System.out.println("Aborted.");
+            return;
+        }
+
+        int processed = 0;
+        for (Tweet tweet : allTweets) {
+            if (processedIds.contains(tweet.id())) {
+                continue;
+            }
+
+            System.out.print(
+                    "Processing " + (processed + 1) + "/" + remainingTweets + "... ");
+            EvaluationResult result =
+                    evaluator.evaluateTweet(tweet.text());
+
+            System.out.println(result.status());
+            csvHandler.writeResult(tweet.id(), tweet.text(),
+                    result.status(), result.reason());
+            processed++;
+            if (processed % 10 == 0) {
+                System.out.println(
+                        "Processed " + processed + " of " + remainingTweets);
+            }
+        }
+
+        System.out.println("DONE! Processed " + processed + " tweets.");
+    }
+
+    private void validateFile(String archivePath) {
+        Path path = Paths.get(archivePath);
+        if (Files.notExists(path)) {
+            System.out.println("Archive does not exist");
+            System.exit(1);
+        }
+
+        if (Files.isDirectory(path)) {
+            System.out.println("Archive is expected to be a file, not a " +
+                    "directory");
+            System.exit(1);
+        }
+    }
+}
diff --git a/src/main/java/parser/TweetData.java b/src/main/java/parser/TweetData.java
new file mode 100644
index 0000000..b69bd6c
--- /dev/null
+++ b/src/main/java/parser/TweetData.java
@@ -0,0 +1,9 @@
+package parser;
+
+import com.google.gson.annotations.SerializedName;
+
+record TweetData(
+        @SerializedName("id_str") String id,
+        @SerializedName("full_text") String text
+) {
+}
diff --git a/src/main/java/parser/TweetWrapper.java b/src/main/java/parser/TweetWrapper.java
new file mode 100644
index 0000000..771a6f2
--- /dev/null
+++ b/src/main/java/parser/TweetWrapper.java
@@ -0,0 +1,4 @@
+package parser;
+
+record TweetWrapper(TweetData tweet) {
+}
diff --git a/src/main/java/parser/TwitterArchiveParser.java b/src/main/java/parser/TwitterArchiveParser.java
new file mode 100644
index 0000000..287f37a
--- /dev/null
+++ b/src/main/java/parser/TwitterArchiveParser.java
@@ -0,0 +1,34 @@
+package parser;
+
+import com.google.gson.Gson;
+import model.Tweet;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class TwitterArchiveParser {
+    public List<Tweet> parseTweets(String filePath) throws IOException {
+        String raw = Files.readString(Path.of(filePath));
+        int start = raw.indexOf('[');
+        int end = raw.lastIndexOf(']') + 1;
+        String json = raw.substring(start, end);
+        Gson gson = new Gson();
+        TweetWrapper[] wrappers =
+                gson.fromJson(json, TweetWrapper[].class);
+
+        List<Tweet> tweets = new ArrayList<>();
+        for (TweetWrapper wrapper : wrappers) {
+            tweets.add(new Tweet(
+                    wrapper.tweet().id(),
+                    wrapper.tweet().text(),
+                    null,
+                    null
+            ));
+        }
+
+        return tweets;
+    }
+}
diff --git a/src/test/java/AI_Client/GeminiClientTest.java b/src/test/java/AI_Client/GeminiClientTest.java
new file mode 100644
index 0000000..ea3fc56
--- /dev/null
+++ b/src/test/java/AI_Client/GeminiClientTest.java
@@ -0,0 +1,45 @@
+package AI_Client;
+
+import model.EvaluationResult;
+import model.enums.ProcessingStatus;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
+
+class GeminiClientTest {
+    @Test
+    void evaluatesTweetSuccessfully() {
+        assumeTrue(System.getenv("GEMINI_API_KEY") != null, "API key not set - skipping");
+        TweetEvaluator evaluator =
+                new GeminiClient(EvaluationCriteria.defaults());
+        String testTweet =
+                "This is how men will bend their back till they reach Badagry? this is fucked up! Damn";
+
+        EvaluationResult result = evaluator.evaluateTweet(testTweet);
+
+        assertNotNull(result);
+        assertNotNull(result.status());
+        assertNotNull(result.reason());
+
+        assertEquals(ProcessingStatus.DELETE, result.status());
+
+        System.out.println("Status: " + result.status());
+        System.out.println("Reason: " + result.reason());
+    }
+
+    @Test
+    void evaluatesCleanTweet() {
+        assumeTrue(System.getenv("GEMINI_API_KEY") != null, "Skipping - no API key");
+
+        TweetEvaluator evaluator =
+                new GeminiClient(EvaluationCriteria.defaults());
+
+        String testTweet =
+                "Just finished a great book on software architecture!";
+
+        EvaluationResult result = evaluator.evaluateTweet(testTweet);
+
+        assertEquals(ProcessingStatus.KEEP, result.status());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/csv/CsvHandlerTest.java b/src/test/java/csv/CsvHandlerTest.java
new file mode 100644
index 0000000..aea9be5
--- /dev/null
+++ b/src/test/java/csv/CsvHandlerTest.java
@@ -0,0 +1,87 @@
+package csv;
+
+import model.enums.ProcessingStatus;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Set;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+class CsvHandlerTest {
+    private CsvHandler csvHandler;
+    private final String testFile = "test-tweets.csv";
+
+    @BeforeEach
+    void setUp() throws IOException {
+        csvHandler = new CsvHandler(testFile);
+        deleteIfExists(testFile);
+        deleteIfExists(
+                testFile.replace(".csv", "_checkpoint.txt"));
+    }
+
+    @AfterEach
+    void tearDown() throws IOException {
+        deleteIfExists(testFile);
+        deleteIfExists(
+                testFile.replace(".csv", "_checkpoint.txt"));
+    }
+
+    @Test
+    void returnsEmptySetWhenFileDoesNotExist() {
+        Set<String> ids = csvHandler.getProcessedTweetIds();
+        assertTrue(ids.isEmpty());
+    }
+
+    @Test
+    void onlyWritesDeletedTweetsToResultsCsv() throws IOException {
+        csvHandler.writeResult("123", "Bad tweet", ProcessingStatus.DELETE, "Offensive");
+        csvHandler.writeResult("456", "Good tweet", ProcessingStatus.KEEP, "Fine");
+
+        Set<String> ids = csvHandler.getProcessedTweetIds();
+        assertEquals(2, ids.size());
+
+        List<String> csvLines = Files.readAllLines(Path.of(testFile));
+        assertEquals(2, csvLines.size());
+        assertTrue(csvLines.get(1).contains("123"));
+        assertFalse(csvLines.get(1).contains("456"));
+    }
+
+    @Test
+    void writesAndReadsBackTweetIds() {
+        csvHandler.writeResult("419", "First model.Tweet",
+                ProcessingStatus.DELETE, "Bad");
+        csvHandler.writeResult("911", "Second model.Tweet",
+                ProcessingStatus.KEEP, "Good");
+
+        Set<String> ids = csvHandler.getProcessedTweetIds();
+
+        assertEquals(2, ids.size());
+        assertTrue(ids.containsAll(Set.of("419", "911")));
+    }
+
+    @Test
+    void appendsWithoutOverwriting() {
+        csvHandler.writeResult("419", "First model.Tweet",
+                ProcessingStatus.DELETE, "Bad");
+        csvHandler.writeResult("911", "Second model.Tweet",
+                ProcessingStatus.KEEP, "Good");
+
+        Set<String> ids = csvHandler.getProcessedTweetIds();
+
+        assertEquals(2, ids.size());
+    }
+
+    private void deleteIfExists(String filename) {
+        File file = new File(filename);
+        if (file.exists() && !file.delete()) {
+            System.err.println("Failed to delete: " + filename);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/parser/TwitterArchiveParserTest.java b/src/test/java/parser/TwitterArchiveParserTest.java
new file mode 100644
index 0000000..6ecae05
--- /dev/null
+++ b/src/test/java/parser/TwitterArchiveParserTest.java
@@ -0,0 +1,29 @@
+package parser;
+
+import model.Tweet;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.List;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+class TwitterArchiveParserTest {
+
+    private TwitterArchiveParser parser;
+
+    @BeforeEach
+    void setUp() {
+        parser = new TwitterArchiveParser();
+    }
+
+    @Test
+    void parsesTweetsFromFile() throws IOException {
+        List<Tweet> tweets = parser.parseTweets("data/tweets.js");
+
+        assertFalse(tweets.isEmpty());
+        assertNotNull(tweets.getFirst().id());
+        assertNotNull(tweets.getFirst().text());
+    }
+}
\ No newline at end of file
